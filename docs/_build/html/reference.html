

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reference &mdash; MNn 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="MNn 1.0 documentation" href="index.html"/>
        <link rel="next" title="Licence" href="license.html"/>
        <link rel="prev" title="Tutorial" href="tutorial.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> MNn
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#miyamoto-nagai-negative-model">Miyamoto-Nagai negative model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#miyamoto-nagai-negative-fitter">Miyamoto-Nagai negative fitter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Licence</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">MNn</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Reference</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/reference.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="variables">
<h2>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h2>
<dl class="data">
<dt id="mnn.model.G">
<code class="descclassname">mnn.model.</code><code class="descname">G</code><em class="property"> = 0.0043008211</em><a class="headerlink" href="#mnn.model.G" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; Gravitational constant to use when evaluating potential or forces on the models.
The value must be changed to match the units required by the user.</p>
</dd></dl>

</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mnn.model.MNnError">
<em class="property">class </em><code class="descclassname">mnn.model.</code><code class="descname">MNnError</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnError" title="Permalink to this definition">¶</a></dt>
<dd><p>Miyamoto-Nagai negative exceptions : raised when the models parameters are in invalid ranges or that the user is doing something he should not</p>
</dd></dl>

</div>
<div class="section" id="miyamoto-nagai-negative-model">
<h2>Miyamoto-Nagai negative model<a class="headerlink" href="#miyamoto-nagai-negative-model" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mnn.model.MNnModel">
<em class="property">class </em><code class="descclassname">mnn.model.</code><code class="descname">MNnModel</code><span class="sig-paren">(</span><em>diz=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Miyamoto-Nagai negative model.
This object is a potential-density pair expansion : it consists of a sum of Miyamoto-Nagai dics allowing</p>
<dl class="method">
<dt id="mnn.model.MNnModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>diz=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the summed Miyamoto-Nagai-negative model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>diz</strong> (<em>float</em>) &#8211; Normalization factor applied to all the discs (default = 1.0)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.add_disc">
<code class="descname">add_disc</code><span class="sig-paren">(</span><em>axis</em>, <em>a</em>, <em>b</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.add_disc" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a Miyamoto-Nagai negative disc to the model, this disc will be included in the summation process when evaluating quantities with the model.</p>
<p>A disc is a list of three parameters <em>a</em>, <em>b</em> and <em>M</em>. All the parameters of the discs are stored in a flat list with no real separation.
This is done so that emcee can be fed the array directly without any transformation.</p>
<p>The model accounts for negative values of <code class="docutils literal"><span class="pre">a</span></code>. The constraints on the parameters are the following :</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></li>
<li><code class="docutils literal"><span class="pre">M</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></li>
<li><code class="docutils literal"><span class="pre">a+b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> (<em>{&#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;}</em>) &#8211; the normal axis of the plane for the disc.</li>
<li><strong>a</strong> (<em>float</em>) &#8211; disc scale</li>
<li><strong>b</strong> (<em>float</em>) &#8211; disc height</li>
<li><strong>M</strong> (<em>float</em>) &#8211; disc mass</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mnn.model.MNnError" title="mnn.model.MNnError"><code class="xref py py-class docutils literal"><span class="pre">mnn.model.MNnError</span></code></a> &#8211; if one of the constraints if not satisfied</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>Adding a disc lying on the xy plane will be done as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MNnModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_disc</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.add_discs">
<code class="descname">add_discs</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.add_discs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for the <a class="reference internal" href="#mnn.model.MNnModel.add_disc" title="mnn.model.MNnModel.add_disc"><code class="xref py py-func docutils literal"><span class="pre">add_disc()</span></code></a> method to add multiple MNn discs at the same time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>values</strong> (<em>list of 4-tuples</em>) &#8211; The parameters of the discs to add. One 4-tuple corresponds to one disc.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="#mnn.model.MNnError" title="mnn.model.MNnError"><code class="xref py py-class docutils literal"><span class="pre">mnn.model.MNnError</span></code></a> &#8211; if one of the constraints if not satisfied</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>Adding one disc on the xy place with parameters (1.0, 0.1, 50.0) and one disc on the yz plane with parameters (1.0, 0.5, 10.0)
will be done as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MNnModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_discs</span><span class="p">([(</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="mnn.model.MNnModel.callback_from_string">
<em class="property">static </em><code class="descname">callback_from_string</code><span class="sig-paren">(</span><em>quantity</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.callback_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the static function callback associated to a given quantity string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">One of the following : <a class="reference internal" href="#mnn.model.MNnModel.mn_density" title="mnn.model.MNnModel.mn_density"><code class="xref py py-func docutils literal"><span class="pre">mn_density()</span></code></a>, <a class="reference internal" href="#mnn.model.MNnModel.mn_potential" title="mnn.model.MNnModel.mn_potential"><code class="xref py py-func docutils literal"><span class="pre">mn_potential()</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">A function callback</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.evaluate_density">
<code class="descname">evaluate_density</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.evaluate_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the summed density over all discs at specific positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x, y, z</strong> (<em>float or Nx1 numpy array</em>) &#8211; Cartesian coordinates of the point(s) to evaluate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The summed density over all discs at position <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">z</span></code> are numpy arrays, then the return value is a Nx1 vector of the evaluated potential
at every point <code class="docutils literal"><span class="pre">(x[i],</span> <span class="pre">y[i],</span> <span class="pre">z[i])</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.evaluate_density_vec">
<code class="descname">evaluate_density_vec</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.evaluate_density_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the summed density of all the discs at specific points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>Nx3 numpy array</em>) &#8211; Cartesian coordinates of the point(s) to evaluate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The summed density over all discs at every position in vector <code class="docutils literal"><span class="pre">x</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.evaluate_potential">
<code class="descname">evaluate_potential</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.evaluate_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the summed potential over all discs at specific positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x, y, z</strong> (<em>float or Nx1 numpy array</em>) &#8211; Cartesian coordinates of the point(s) to evaluate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The summed potential over all discs at position <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">z</span></code> are numpy arrays, then the return value is a Nx1 value of the potential evaluated
at every point <code class="docutils literal"><span class="pre">(x[i],</span> <span class="pre">y[i],</span> <span class="pre">z[i])</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.evaluate_potential_vec">
<code class="descname">evaluate_potential_vec</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.evaluate_potential_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the summed potential of all the discs at specific points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>Nx3 numpy array</em>) &#8211; Cartesian coordinates of the point(s) to evaluate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The summed potential over all discs at every position in vector <code class="docutils literal"><span class="pre">x</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.generate_dataset_meshgrid">
<code class="descname">generate_dataset_meshgrid</code><span class="sig-paren">(</span><em>xmin</em>, <em>xmax</em>, <em>dx</em>, <em>quantity='density'</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.generate_dataset_meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a numpy meshgrid of data from the model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xmin</strong> (<em>3-tuple of floats</em>) &#8211; The low bound of the box</li>
<li><strong>xmax</strong> (<em>3-tuple of floats</em>) &#8211; The high bound of the box</li>
<li><strong>dx</strong> (<em>3-tuple of floats</em>) &#8211; Mesh spacing in every direction</li>
<li><strong>quantity</strong> (<em>{&#8216;density&#8217;, &#8216;potential&#8217;}</em>) &#8211; Type of quantity to fill the box with (default=&#8217;density&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A 4-tuple containing</p>
<ul class="simple">
<li><strong>vx, vy, vz</strong> (<em>N vector of floats</em>): The x, y and z coordinates of each point of the mesh</li>
<li><strong>res</strong> (<em>N vector of floats</em>): The values of the summed quantity over all discs at each point of the mesh</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">MemoryError</span></code> &#8211; If the array is too big</li>
<li><a class="reference internal" href="#mnn.model.MNnError" title="mnn.model.MNnError"><code class="xref py py-class docutils literal"><span class="pre">mnn.model.MNnError</span></code></a> &#8211; If the quantity parameter does not correspond to anything known</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the discs currently stored and returns them as a list of 4-tuples [(axis1, a1, b1, M1), (axis2, a2, b2, ...), ... ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of 4-tuples (axis, a, b, M).</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MNnModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_discs</span><span class="p">([(</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">get_model</span><span class="p">()</span>
<span class="go">[(&#39;z&#39;, 1.0, 0.1, 50.0), (&#39;x&#39;, 1.0, 0.5, 10.0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.model.MNnModel.is_positive_definite">
<code class="descname">is_positive_definite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.is_positive_definite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the sum of the discs are positive definite.</p>
<p>The methods tests along every axis if the minimum of density is positive. If it is not the case then the model should
NOT be used since we cannot ensure positive density everywhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A boolean indicating if the model is positive definite.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="mnn.model.MNnModel.mn_density">
<em class="property">static </em><code class="descname">mn_density</code><span class="sig-paren">(</span><em>r</em>, <em>z</em>, <em>a</em>, <em>b</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.mn_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the density of a single Miyamoto-Nagai negative disc (a, b, M) at polar coordinates (r, z).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) &#8211; radius of the point where the density is evaluated</li>
<li><strong>z</strong> (<em>float</em>) &#8211; height of the point where the density is evaluated</li>
<li><strong>a</strong> (<em>float</em>) &#8211; disc scale</li>
<li><strong>b</strong> (<em>float</em>) &#8211; disc height</li>
<li><strong>M</strong> (<em>float</em>) &#8211; disc mass</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the density (scaled to the model) at (r, z)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><em>float</em></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method does <strong>not</strong> check the validity of the constraints <code class="docutils literal"><span class="pre">b&gt;=0</span></code>, <code class="docutils literal"><span class="pre">M&gt;=0</span></code>, <code class="docutils literal"><span class="pre">a+b&gt;=0</span></code></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="mnn.model.MNnModel.mn_potential">
<em class="property">static </em><code class="descname">mn_potential</code><span class="sig-paren">(</span><em>r</em>, <em>z</em>, <em>a</em>, <em>b</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.model.MNnModel.mn_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the potential of a single Miyamoto-Nagai negative disc (a, b, M) at polar coordinates (r, z).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) &#8211; radius of the point where the density is evaluated</li>
<li><strong>z</strong> (<em>float</em>) &#8211; height of the point where the density is evaluated</li>
<li><strong>a</strong> (<em>float</em>) &#8211; disc scale</li>
<li><strong>b</strong> (<em>float</em>) &#8211; disc height</li>
<li><strong>Mo</strong> (<em>float</em>) &#8211; disc mass</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the potential (scaled to the model) at (r, z)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><em>float</em></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method does <strong>not</strong> check the validity of the constraints <code class="docutils literal"><span class="pre">b&gt;=0</span></code>, <code class="docutils literal"><span class="pre">M&gt;=0</span></code>, <code class="docutils literal"><span class="pre">a+b&gt;=0</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method relies on user-specified value for the gravitational constant.
This value can be overriden by setting the value <a class="reference internal" href="#mnn.model.G" title="mnn.model.G"><code class="xref py py-data docutils literal"><span class="pre">mnn.model.G</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="miyamoto-nagai-negative-fitter">
<h2>Miyamoto-Nagai negative fitter<a class="headerlink" href="#miyamoto-nagai-negative-fitter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mnn.fitter.MNnFitter">
<em class="property">class </em><code class="descclassname">mnn.fitter.</code><code class="descname">MNnFitter</code><span class="sig-paren">(</span><em>n_walkers=100</em>, <em>n_steps=1000</em>, <em>n_threads=1</em>, <em>random_seed=123</em>, <em>fit_type='density'</em>, <em>check_positive_definite=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Miyamoto-Nagai negative fitter.</p>
<p>This class is used to fit the parameters of a Miyamoto-Nagai negative model to data.
(with a predefined number of discs) to a datafile.</p>
<dl class="method">
<dt id="mnn.fitter.MNnFitter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>n_walkers=100</em>, <em>n_steps=1000</em>, <em>n_threads=1</em>, <em>random_seed=123</em>, <em>fit_type='density'</em>, <em>check_positive_definite=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the Miyamoto-Nagai negative fitter. The fitting is based on <code class="docutils literal"><span class="pre">emcee</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_walkers</strong> (<em>int</em>) &#8211; How many parallel walkers <code class="docutils literal"><span class="pre">emcee</span></code> will use to fit the data (default=100).</li>
<li><strong>n_step</strong> (<em>int</em>) &#8211; The number of steps every walker should perform before stopping (default=1000).</li>
<li><strong>n_threads</strong> (<em>int</em>) &#8211; Number of threads used to fit the data (default=1).</li>
<li><strong>random_seed</strong> (<em>int</em>) &#8211; The random seed used for the fitting (default=123).</li>
<li><strong>fit_type</strong> (<em>{&#8216;density&#8217;, &#8216;potential&#8217;}</em>) &#8211; What type of data is fitted (default=&#8217;density&#8217;).</li>
<li><strong>check_positive_definite</strong> (<em>bool</em>) &#8211; Should the algorithm check if every walker is positive definite at every step ?</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; Should the program output additional information (default=False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using <code class="docutils literal"><span class="pre">check_positive_definite=True</span></code> might guarantee that the density will be always positive. But
this takes a toll on the computation. We advise to fit the data with <code class="docutils literal"><span class="pre">check_positive_definite=False</span></code>.
If the result is not definite positive, then switch this flag on and re-do the fitting.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.compute_quantiles">
<code class="descname">compute_quantiles</code><span class="sig-paren">(</span><em>samples</em>, <em>quantiles=(16</em>, <em>50</em>, <em>84)</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.compute_quantiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the quantiles values on the whole sample kept after emcee run.</p>
<p>This method computes the values of the parameters of the model at each specified quantile.
For instance, if the desired quantiles is only <code class="docutils literal"><span class="pre">(50)</span></code>, then the returned array will correspond to the median value for each parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>numpy array</em>) &#8211; The result of fit-data, that will be processed</li>
<li><strong>quantiles</strong> (<em>tuple</em>) &#8211; What quantiles are to be computed (default=(16, 50, 84))</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A numpy array corresponding to the values, for each parameter and for each quantile.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.corner_plot">
<code class="descname">corner_plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.corner_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the corner plot of the fitted data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this method fails it might mean the fitting has not properly converged yet.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The corner plot object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.fit_data">
<code class="descname">fit_data</code><span class="sig-paren">(</span><em>burnin=100</em>, <em>x0=None</em>, <em>x0_range=0.0001</em>, <em>plot_freq=0</em>, <em>plot_ids=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.fit_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs <code class="docutils literal"><span class="pre">emcee</span></code> to fit the model to the data.</p>
<p>Fills the <code class="xref py py-data docutils literal"><span class="pre">mnn.fitter.sampler</span></code> object with the putative models and returns the burned-in data. The walkers are initialized
randomly around position <cite>x0</cite> with a maximum dispersion of <cite>x0_range</cite>. This ball is the initial set of solutions and should be
centered on the initial guess of what the parameters are.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>burnin</strong> (<em>int</em>) &#8211; The number of timesteps to remove from every walker after the end (default=100).</li>
<li><strong>x0</strong> (<em>numpy array</em>) &#8211; The initial guess for the solution (default=None). If None, then x0 is determined randomly.</li>
<li><strong>x0_range</strong> (<em>float</em>) &#8211; The radius of the inital guess walker ball (default=1e-4)</li>
<li><strong>plot_freq</strong> (<em>int</em>) &#8211; The frequency at which the system outputs control plot (default=0). If 0, then the system does not plot anything until the end.</li>
<li><strong>plot_ids</strong> (<em>array</em>) &#8211; The id of the discs to plot during the control plots (default=[]). If empty array, then every disc is plotted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A tuple containing</p>
<ul class="simple">
<li><strong>samples</strong> (numpy array): A 2D numpy array holding every parameter value for every walker after timestep <code class="docutils literal"><span class="pre">burnin</span></code></li>
<li><strong>lnprobability</strong> (numpy array): The samplers pointer to the matrix value of the log likelihood produced by each walker at every timestep after <code class="docutils literal"><span class="pre">burnin</span></code></li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">MNnError</span></code> &#8211; If the user tries to fit the data without having called <a class="reference internal" href="#mnn.fitter.MNnFitter.load_data" title="mnn.fitter.MNnFitter.load_data"><code class="xref py py-func docutils literal"><span class="pre">load_data()</span></code></a> before.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The plots are outputted in the folder where the script is executed, in the file <code class="docutils literal"><span class="pre">current_state.png</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.get_residuals">
<code class="descname">get_residuals</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.get_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the residual between the data and the model you provide as input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model</strong> (<em>numpy array</em>) &#8211; The Ndiscs*3 parameter values of the model you want to compute the residuals on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A numpy array storing the residual value for every point of the data.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">MNnError</span></code> &#8211; If the user tries to compute the residual without having called <a class="reference internal" href="#mnn.fitter.MNnFitter.load_data" title="mnn.fitter.MNnFitter.load_data"><code class="xref py py-func docutils literal"><span class="pre">load_data()</span></code></a> before.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.load_data">
<code class="descname">load_data</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the data that will be fitted to the model.</p>
<p>The data should be in an ascii file with four columns tab or space separated : X Y Z quantity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; The filename to open.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.loglikelihood">
<code class="descname">loglikelihood</code><span class="sig-paren">(</span><em>discs</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.loglikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log likelihood of a given model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>discs</strong> (<em>tuple</em>) &#8211; the list of parameters for the model stored in a flat-tuple (a1, b1, M1, a2, b2, ...)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The loglikelihood of the model given in parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.maximum_likelihood">
<code class="descname">maximum_likelihood</code><span class="sig-paren">(</span><em>discs</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.maximum_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the maximum likelihood for a given model and stores them in <code class="docutils literal"><span class="pre">MNnFitter.model</span></code></p>
<p>The calculation is based on scipy optimization routines to maximize the likelihood of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>discs</strong> (<em>tuple</em>) &#8211; the initial guess for the values of the parameters stored in a flat-tuple (a1, b1, M1, a2, b2, ...)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The parameters corresponding to the maximized chi-square log likelihood</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.plot_disc_walkers">
<code class="descname">plot_disc_walkers</code><span class="sig-paren">(</span><em>id_discs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.plot_disc_walkers" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting the walkers on each parameter of a certain disc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id_disc</strong> (<em>int of list</em>) &#8211; the ids of the disc parameters you want to plot. If None, all the discs are plotted</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The matplotlib figure object. You can either plot it or save it.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mnn.fitter.MNnFitter.set_model_type">
<code class="descname">set_model_type</code><span class="sig-paren">(</span><em>nx=0</em>, <em>ny=0</em>, <em>nz=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mnn.fitter.MNnFitter.set_model_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the type of Miyamoto-nagai negative model that will be fitted</p>
<p>This method allows to set the number of discs available to put in the model along each plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> (<em>int</em>) &#8211; Number of discs on the yz plane (default=0).</li>
<li><strong>ny</strong> (<em>int</em>) &#8211; Number of discs on the xz plane (default=0).</li>
<li><strong>nz</strong> (<em>int</em>) &#8211; Number of discs on the xy plane (default=1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="license.html" class="btn btn-neutral float-right" title="Licence" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorial.html" class="btn btn-neutral" title="Tutorial" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Armando Rojas-Niño, Justin I. Read, Luis Aguilar, Maxime Delorme.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>